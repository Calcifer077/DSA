Abstract class is a restricted class that cannot be used to create objects.

.........................................................................................
.........................................................................................

Super keyword is used to refer to the parent class.

.........................................................................................
.........................................................................................
@Override function is used to indicate that the method of the child class is overriding the method of the Base class.
It is also used for improving code reusabilty.
.........................................................................................
.........................................................................................
Final keyword :--->
It is used to restrict the user.
It can be used in many contexts:
1. Variable ---> To create constant variable
2. Method ---> To prevent method overriding
3. classes ---> To prevent inheritance
.........................................................................................
.........................................................................................
File Handling is used to store data in the permanent memory.
To know about the information of the file you must include:
" imort java.io.File; "

Java File class methods:
boolean canRead() -> Check whether we can read the data or not.
boolean createNewFile() -> used to create a new emoty file.
boolean canWrite() -> check whether we can write the data into the file or not.
boolean exists() -> used to check whether the specified file is present or not.
boolean delete() -> used to delete a file.
String getName() -> used to find the file name.
String getAbsolutePath()	-> used to get the absolute pathname of the file.


Several exceptions in the java.io package might occur when you are working with files and streams.

-> A FileNotFound exception occurs when you try to create a stream or file object using a file that couldn’t be located.
-? An EOFException indicates that the end of a file has been reached unexpectedly as data was being read from the file through an input stream.
These exceptions are subclasses of IOException. One way to deal with all of them is to enclose all input and output statements in a try-catch block that catches IOException objects. Call the exception’s toString() or getMessage() methods in the catch block to find out more about the problem

InputStream	-> Abstract class containing methods for performing input. to write data to a destination, it may be a file, an array, peripheral devices or socket.
OutputStream -> Abstract class containing methods for performing output, to read data from a source, it may be a file, an array, peripheral device or socket.
FileInputStream	-> Child of InputStream that provides the capability to read from disk files. For reading streams of characters FileReader class is recommended.
FileOutputStream -> Child of OutputStream that provides the capability to write to disk files. If you have to write primitive values into a file. We can write charcter oriented as well, but for this FileWriter is recommended.
PrintStream	-> Child of FilterOutputStream, which is a child of OutputStream; PrintStream handles output to a system’s standard (or default) output device, usually the monitor
BufferedInputStream	-> Child of FilterInputStream, which is a child of InputStream; BufferedInputStream handles input from a system’s standard (or default) input device, usually the keyboard.


.........................................................................................
.........................................................................................

Stream represents the pipleline through which data will flow and the funcitons to operate on data.

ByteArrayInputStream is used to read byte array as a input stream.
ByteArrayOutputStream is used to write byte array in more than one file at a time.

PipedWriter and PipedReader are used to read a stream of characters.
These two classes are used in pairs.

.........................................................................................
.........................................................................................

Serialization -> It is a mechanism where an object can be represented as a sequence of bytes that include's the object's data as well as information about the object's type and the types of data stored in the object.

After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.

Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized on an entirely different platform.

.........................................................................................
.........................................................................................
Multitasking ---> It is the process when CPU allocate CPU time to different processes to complete their execution.
CPU divides specific time slices for each processes to execute their block of code.

Multithreading ---> It is the process in which OS divides a single process into multiple threads which can execute concurrently.

Synchronization is used when we have multiple threads trying to access a single resource.
The main pupose of Syncronization is to overcome the problem of multithreading when multiple threads try to access a single resource.
When using synchronization, this method will place a lock(a monitor) on an important object or piece code to make sure that only one thread can access it at the same time.
To protect data, below two things must be done:
1. Make the variables private.
2. Synchronize the code that modifies the variable.

Real life example of Synchronization:->
Suppose three people have a joint account in a bank and all three try to access the money at the same time.
Synchronization can be achieved by two ways:
1. Method level
2. Block level

.........................................................................................
.........................................................................................
Object Cloning ---> Object cloning is a way to create an exact copy of an object. The clone() method is used for implementation.
                        -> java.lang.Cloneable interface must be implemented.
                        -> The clone() method saves the extra proessing task for creating the exact copy of an object.If we perform it by                            using the 'new' keyword, it will take a lot of pocessing time.
                        
.........................................................................................
.........................................................................................
Exception -> A java exception is an object that describes an exceptional condition that has occurred in a piece of code. When an exceptional condition arises, an object representing that exception is created and thrown in the method that caused the error. That method may choose to handle the exception itself or pass it on. Either way, at some point, the exception is caught and processed.

There are two ways of handling exceptions:
1. Catch the exception and take corrective action
2. Throw the exception to the calling method which will force the calling method to handle it.  

Java exception handling is done using try...catch block. The try...catch block are used in pair.

The try statement allows you to define a block of code to be tested for errors while it is being executed.
The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.

finally -> The finally statement lets you execute code, after try...catch, regardless of the result.

throw -> The throw statement allows you to create custom error. The throw statement is used together with an exception type. There are many exception types available in Java: ArithmeticException, FileNotFoundException, ArrayIndexOutOfBoundsException, SecurityException, etc.

The try...catch block can be nested.

.........................................................................................
.........................................................................................

AWT(Abstract window toolkit) -> used to make GUI or window based applications in java.
-> Components of awt are platform-dependent and heavyweight.
-> AWT has less control as the result can differ because of components are platform dependent.
-> AWT is platform independent not its components.

Why AWT is Platform Independent?
The Java AWT utilizes the native platform subroutine to create API components such as TextField, CheckBox, and buttons. This results in a different visual format for these components on different platforms such as Windows, MAC OS, and Unix. The reason for this is that each platform has a distinct view of its native components.

AWT is platform independent even after the AWT components are platform dependent because of the points mentioned below:
1. JVM is platform dependent.
2. Abstract APIs
3.  Platform-Independent Libraries

Different things in AWT:
-> Components: AWT provides various components such as buttons, labels, text fields, checkboxes, etc used for creating GUI elements for Java Applications.
-> Containers: AWT provides containers like panels, frames, and dialogues to organize and group components in the Application.
-> Layout Managers: Layout Managers are responsible for arranging data in the containers sone of the layout managers are BorderLayout, FlowLayout, etc.
-> Event Handling: AWT allows the user to handle the events like mouse clicks, key presses, etc. using event listeners and adapters.
-> Graphics and Drawing: It is the feature of AWT that helps to draw shapes, insert images and write text in the components of a Java Application.

Methods of component class:
public void add(Component c)	-> Inserts a component on this component.
public void setSize(int width,int height)	-> Sets the size (width and height) of the component.
public void setLayout(LayoutManager m)	-> Defines the layout manager for the component.
public void setVisible(boolean status)	-> Changes the visibility of the component, by default false.

* Container is a component that can contain other components.
Types of Containers in Java AWT
There are four types of containers in Java AWT:
-> Window: Window is a top-level container that represents a graphical window or dialog box. The Window class extends the Container class, which means it can contain other components, such as buttons, labels, and text fields.
-> Panel: Panel is a container class in Java. It is a lightweight container that can be used for grouping other components together within a window or a frame.
-> Frame: The Frame is the container that contains the title bar and border and can have menu bars.
-> Dialog: A dialog box is a temporary window an application creates to retrieve user input.


-> Label --> A Label object is a component for placing text in a container. A label displays a single line of read-only text. The text can be changed by the application, but a user cannot edit it directly.
-> Button --> AWT Button is a control component with a label that generates an event when clicked on. Button Class is used for creating a labeled button that is platform-independent.
-> TextField --> A TextField object is a text component that allows for the editing of a single line of text.
-> CheckBox --> It is used to turn an option on (true) or off (false). Clicking on a Checkbox changes its state from "on" to "off" or from "off" to "on".
-> CheckboxGroup --> CheckboxGroup Class is used to group together a set of Checkbox.
Note: CheckboxGroup enables the use of radio buttons in AWT.
-> Choice --> The Choice class displays a popup menu to the user, from which the user can pick an item.
-> Panel --> Java AWT Panel is a container class used to hold and organize graphical components in a Java Application.
-> Toolkit --> Java AWT Toolkit class provides us with a platform-independent way to access various system resources and functionalities. Subclasses of Toolkit are used to bind various components.

To create a simple awt:
1. By extending Frame class (inheritance)
2. By creating the object of Frame class (association)

Event handling:
Changing the state of an object is known as an event. For example, click on button, dragging mouse etc. The java.awt.event package provides many event classes and Listener interfaces for event handling.

Various type of event handling components:
1. Java ActionListener -> Java ActionListner is a interface which responds to the actions performed by the components like buttons, menu items ,etc.
2. Java MouseListener -> Java MouseListner is a interface that responds to the actions performed by mouse events generated by the user. Example: mouse clicks , mouse movements, etc.
3. Java MouseMotionListener -> Java MouseMotionListner is a interface which is notified when mouse is moved or dragged.
4. Java ItemListner -> Java ItemListner is an interface which handles events related to item selection and deselection those that occur with checkboxes, radio buttons, etc.
5. Java KeyListener -> Java KeyListner is an interface in Java notified whenever you change the state of key or can be said for key related events.(Key -> Keyboard)
6. Java WindowListener -> Java WindowListener is a interface used for handling events related to window actions. Events like opening , closing, minimizing, etc are handled using WindowListener.

* Close AWT Window -> At the end we will need to Close AWT Window, So to perform this task we will use dispose() method. This method releases the resources associated with the window and also removes it from the screen.

We can put the event handling code into one of the following places:
1. Within class
2. Other class
3. Anonymous class
